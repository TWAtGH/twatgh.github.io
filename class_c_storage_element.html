<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gacspp: CStorageElement Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">gacspp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_c_storage_element.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_c_storage_element-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">CStorageElement Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Represents a storage element. Only basic functionality is implemented directly. The rest is delegated to the contained <a class="el" href="class_i_storage_element_delegate.html" title="Delegate definition declaring the methods required to implement a storage element delegate....">IStorageElementDelegate</a> object.  
 <a href="class_c_storage_element.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_c_storage_element_8hpp_source.html">CStorageElement.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CStorageElement:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_c_storage_element.png" usemap="#CStorageElement_map" alt=""/>
  <map id="CStorageElement_map" name="CStorageElement_map">
<area href="classgcp_1_1_c_bucket.html" title="CStorageElement specification to represent a GCP bucket." alt="gcp::CBucket" shape="rect" coords="0,56,109,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:adea7b7bdc5316eec962f4cef2fbc9846"><td class="memItemLeft" align="right" valign="top"><a id="adea7b7bdc5316eec962f4cef2fbc9846" name="adea7b7bdc5316eec962f4cef2fbc9846"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_storage_element.html#adea7b7bdc5316eec962f4cef2fbc9846">OPERATION</a> { <br />
&#160;&#160;<b>INSERT</b>
, <b>GET</b>
, <b>CREATE_TRANSFER</b>
, <b>DELETE</b>
, <br />
&#160;&#160;<b>CUSTOM</b>
<br />
 }</td></tr>
<tr class="memdesc:adea7b7bdc5316eec962f4cef2fbc9846"><td class="mdescLeft">&#160;</td><td class="mdescRight">The types of operations that can be triggered on a storage element. <br /></td></tr>
<tr class="separator:adea7b7bdc5316eec962f4cef2fbc9846"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8703731500cf7499f1733923c18daf4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_storage_element.html#a8703731500cf7499f1733923c18daf4b">CStorageElement</a> (std::string &amp;&amp;name, <a class="el" href="class_i_site.html">ISite</a> *site, bool allowDuplicateReplicas=false, <a class="el" href="constants_8h.html#a2dcadd59ab48e48ddc4b2a44e9a0cb75">SpaceType</a> limit=0)</td></tr>
<tr class="memdesc:a8703731500cf7499f1733923c18daf4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to create a new storage element. Used by an <a class="el" href="class_i_site.html" title="Interface for a storage resource site.">ISite</a> object.  <a href="class_c_storage_element.html#a8703731500cf7499f1733923c18daf4b">More...</a><br /></td></tr>
<tr class="separator:a8703731500cf7499f1733923c18daf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95854dd7e31e47ae2643b8e47ea3456"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_storage_element.html#ab95854dd7e31e47ae2643b8e47ea3456">OnOperation</a> (<a class="el" href="class_c_storage_element.html#adea7b7bdc5316eec962f4cef2fbc9846">OPERATION</a> op)</td></tr>
<tr class="memdesc:ab95854dd7e31e47ae2643b8e47ea3456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method that notifies the storage element about an executed operation, e.g., data access or deletion.  <a href="class_c_storage_element.html#ab95854dd7e31e47ae2643b8e47ea3456">More...</a><br /></td></tr>
<tr class="separator:ab95854dd7e31e47ae2643b8e47ea3456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705d18996997988bb52033f7981cc6e1"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_storage_element.html#a705d18996997988bb52033f7981cc6e1">CreateNetworkLink</a> (<a class="el" href="class_c_storage_element.html">CStorageElement</a> *dstStorageElement, <a class="el" href="constants_8h.html#a2dcadd59ab48e48ddc4b2a44e9a0cb75">SpaceType</a> bandwidth) -&gt; <a class="el" href="class_c_network_link.html">CNetworkLink</a> *</td></tr>
<tr class="memdesc:a705d18996997988bb52033f7981cc6e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to create a new network link that originates from this storage element to the given destination storage element.  <a href="class_c_storage_element.html#a705d18996997988bb52033f7981cc6e1">More...</a><br /></td></tr>
<tr class="separator:a705d18996997988bb52033f7981cc6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac578cb7de73593f0fe50bf503dcdde92"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_storage_element.html#ac578cb7de73593f0fe50bf503dcdde92">CreateReplica</a> (<a class="el" href="struct_s_file.html">SFile</a> *file, <a class="el" href="constants_8h.html#ad0daaa7f1a5dd0956501ba62b4527644">TickType</a> now) -&gt; <a class="el" href="struct_s_replica.html">SReplica</a> *</td></tr>
<tr class="memdesc:ac578cb7de73593f0fe50bf503dcdde92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to create a new replica of the given file at this storage element. Replica will be empty.  <a href="class_c_storage_element.html#ac578cb7de73593f0fe50bf503dcdde92">More...</a><br /></td></tr>
<tr class="separator:ac578cb7de73593f0fe50bf503dcdde92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210cc8d65e56fc659e2886c724742903"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_storage_element.html#a210cc8d65e56fc659e2886c724742903">RemoveReplica</a> (<a class="el" href="struct_s_replica.html">SReplica</a> *replica, <a class="el" href="constants_8h.html#ad0daaa7f1a5dd0956501ba62b4527644">TickType</a> now, bool needLock=true)</td></tr>
<tr class="memdesc:a210cc8d65e56fc659e2886c724742903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a replica from the storage element, freeing the storage space it consumed.  <a href="class_c_storage_element.html#a210cc8d65e56fc659e2886c724742903">More...</a><br /></td></tr>
<tr class="separator:a210cc8d65e56fc659e2886c724742903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1de579e009b4462e8a9f34b43eede9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_storage_element.html#abc1de579e009b4462e8a9f34b43eede9">OnIncreaseReplica</a> (<a class="el" href="struct_s_replica.html">SReplica</a> *replica, <a class="el" href="constants_8h.html#a2dcadd59ab48e48ddc4b2a44e9a0cb75">SpaceType</a> amount, <a class="el" href="constants_8h.html#ad0daaa7f1a5dd0956501ba62b4527644">TickType</a> now)</td></tr>
<tr class="memdesc:abc1de579e009b4462e8a9f34b43eede9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the storage element that the storage spaced consumed by the given replica was increased.  <a href="class_c_storage_element.html#abc1de579e009b4462e8a9f34b43eede9">More...</a><br /></td></tr>
<tr class="separator:abc1de579e009b4462e8a9f34b43eede9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cc24e7f98cc5fe2549b35c10eb052f"><td class="memItemLeft" align="right" valign="top"><a id="a02cc24e7f98cc5fe2549b35c10eb052f" name="a02cc24e7f98cc5fe2549b35c10eb052f"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>GetId</b> () const -&gt; <a class="el" href="constants_8h.html#aa145ea91c3e0724923e48e2eb0befe88">IdType</a></td></tr>
<tr class="separator:a02cc24e7f98cc5fe2549b35c10eb052f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12c6b0fa6f887f16c6c1fcfef5b1a2a"><td class="memItemLeft" align="right" valign="top"><a id="af12c6b0fa6f887f16c6c1fcfef5b1a2a" name="af12c6b0fa6f887f16c6c1fcfef5b1a2a"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>GetName</b> () const -&gt; const std::string &amp;</td></tr>
<tr class="separator:af12c6b0fa6f887f16c6c1fcfef5b1a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad497ab3084bb442b760cc6843b0500ff"><td class="memItemLeft" align="right" valign="top"><a id="ad497ab3084bb442b760cc6843b0500ff" name="ad497ab3084bb442b760cc6843b0500ff"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>GetSite</b> () const -&gt; <a class="el" href="class_i_site.html">ISite</a> *</td></tr>
<tr class="separator:ad497ab3084bb442b760cc6843b0500ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c0825313aa81074de26762c1657b1a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_storage_element.html#aa6c0825313aa81074de26762c1657b1a">GetReplicas</a> () const -&gt; const std::vector&lt; std::unique_ptr&lt; <a class="el" href="struct_s_replica.html">SReplica</a> &gt; &gt; &amp;</td></tr>
<tr class="memdesc:aa6c0825313aa81074de26762c1657b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter to get a const reference to the internal array storing all replicas of the storage element (copying could be expensive)  <a href="class_c_storage_element.html#aa6c0825313aa81074de26762c1657b1a">More...</a><br /></td></tr>
<tr class="separator:aa6c0825313aa81074de26762c1657b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e36935ec99a2fb7b43a1a24aba87d93"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_storage_element.html#a7e36935ec99a2fb7b43a1a24aba87d93">GetNetworkLinks</a> () const -&gt; const std::vector&lt; std::unique_ptr&lt; <a class="el" href="class_c_network_link.html">CNetworkLink</a> &gt; &gt; &amp;</td></tr>
<tr class="memdesc:a7e36935ec99a2fb7b43a1a24aba87d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter to get a const reference to the internal array storing the networklinks going out of this storage element.  <a href="class_c_storage_element.html#a7e36935ec99a2fb7b43a1a24aba87d93">More...</a><br /></td></tr>
<tr class="separator:a7e36935ec99a2fb7b43a1a24aba87d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b98641f2ed3ba492ca4886028cfe621"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_storage_element.html#a6b98641f2ed3ba492ca4886028cfe621">GetNetworkLink</a> (const <a class="el" href="class_c_storage_element.html">CStorageElement</a> *dstStorageElement) const -&gt; <a class="el" href="class_c_network_link.html">CNetworkLink</a> *</td></tr>
<tr class="memdesc:a6b98641f2ed3ba492ca4886028cfe621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to get a networklink connection this storage element with a given destination storage element.  <a href="class_c_storage_element.html#a6b98641f2ed3ba492ca4886028cfe621">More...</a><br /></td></tr>
<tr class="separator:a6b98641f2ed3ba492ca4886028cfe621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed323816f6b9f7fb084b2f233e65e903"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_storage_element.html#aed323816f6b9f7fb084b2f233e65e903">GetUsedStorage</a> () const -&gt; <a class="el" href="constants_8h.html#a2dcadd59ab48e48ddc4b2a44e9a0cb75">SpaceType</a></td></tr>
<tr class="memdesc:aed323816f6b9f7fb084b2f233e65e903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the amount of storage space used by this storage element.  <a href="class_c_storage_element.html#aed323816f6b9f7fb084b2f233e65e903">More...</a><br /></td></tr>
<tr class="separator:aed323816f6b9f7fb084b2f233e65e903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c408be2771d70c4de8c4c69cb70a10c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_storage_element.html#a5c408be2771d70c4de8c4c69cb70a10c">GetAllocatedStorage</a> () const -&gt; <a class="el" href="constants_8h.html#a2dcadd59ab48e48ddc4b2a44e9a0cb75">SpaceType</a></td></tr>
<tr class="memdesc:a5c408be2771d70c4de8c4c69cb70a10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the amount of storage space allocated at this storage element.  <a href="class_c_storage_element.html#a5c408be2771d70c4de8c4c69cb70a10c">More...</a><br /></td></tr>
<tr class="separator:a5c408be2771d70c4de8c4c69cb70a10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77cd228e5d276b0c2921b7a925087dec"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_storage_element.html#a77cd228e5d276b0c2921b7a925087dec">GetLimit</a> () const -&gt; <a class="el" href="constants_8h.html#a2dcadd59ab48e48ddc4b2a44e9a0cb75">SpaceType</a></td></tr>
<tr class="memdesc:a77cd228e5d276b0c2921b7a925087dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the maximum of storage that can used.  <a href="class_c_storage_element.html#a77cd228e5d276b0c2921b7a925087dec">More...</a><br /></td></tr>
<tr class="separator:a77cd228e5d276b0c2921b7a925087dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8f3a873926efb2e04b9f40aac1d2ee"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_storage_element.html#a6b8f3a873926efb2e04b9f40aac1d2ee">GetUsedStorageLimitRatio</a> () const -&gt; double</td></tr>
<tr class="memdesc:a6b8f3a873926efb2e04b9f40aac1d2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the ratio between used storage and the storage limit.  <a href="class_c_storage_element.html#a6b8f3a873926efb2e04b9f40aac1d2ee">More...</a><br /></td></tr>
<tr class="separator:a6b8f3a873926efb2e04b9f40aac1d2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0530d39192ebfa6c0332224e404f990"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_storage_element.html#ab0530d39192ebfa6c0332224e404f990">CanStoreVolume</a> (<a class="el" href="constants_8h.html#a2dcadd59ab48e48ddc4b2a44e9a0cb75">SpaceType</a> volume) const</td></tr>
<tr class="memdesc:ab0530d39192ebfa6c0332224e404f990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the given volume can be allocated at this storage element.  <a href="class_c_storage_element.html#ab0530d39192ebfa6c0332224e404f990">More...</a><br /></td></tr>
<tr class="separator:ab0530d39192ebfa6c0332224e404f990"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af138575cfc3d5b8e13804932e129152b"><td class="memItemLeft" align="right" valign="top"><a id="af138575cfc3d5b8e13804932e129152b" name="af138575cfc3d5b8e13804932e129152b"></a>
std::vector&lt; <a class="el" href="class_i_storage_element_action_listener.html">IStorageElementActionListener</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mActionListener</b></td></tr>
<tr class="memdesc:af138575cfc3d5b8e13804932e129152b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The action listener interface implementations associated with this storage element instance. <br /></td></tr>
<tr class="separator:af138575cfc3d5b8e13804932e129152b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae9aa607ee876d0c005388476c7bc2b"><td class="memItemLeft" align="right" valign="top"><a id="a0ae9aa607ee876d0c005388476c7bc2b" name="a0ae9aa607ee876d0c005388476c7bc2b"></a>
std::unique_ptr&lt; class <a class="el" href="class_i_value_generator.html">IValueGenerator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mAccessLatency</b></td></tr>
<tr class="memdesc:a0ae9aa607ee876d0c005388476c7bc2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random value generator for the access latency of this storage element. <br /></td></tr>
<tr class="separator:a0ae9aa607ee876d0c005388476c7bc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a932945889dab3160812d9d1d0a8ff1b0"><td class="memItemLeft" align="right" valign="top"><a id="a932945889dab3160812d9d1d0a8ff1b0" name="a932945889dab3160812d9d1d0a8ff1b0"></a>
<a class="el" href="class_i_site.html">ISite</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mSite</b></td></tr>
<tr class="memdesc:a932945889dab3160812d9d1d0a8ff1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the site that owns this storage element <br /></td></tr>
<tr class="separator:a932945889dab3160812d9d1d0a8ff1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2811b15a2087f7fa1525098db2656f23"><td class="memItemLeft" align="right" valign="top"><a id="a2811b15a2087f7fa1525098db2656f23" name="a2811b15a2087f7fa1525098db2656f23"></a>
std::unique_ptr&lt; <a class="el" href="class_i_storage_element_delegate.html">IStorageElementDelegate</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mDelegate</b></td></tr>
<tr class="memdesc:a2811b15a2087f7fa1525098db2656f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the delegate implementing the functionality of this storage element <br /></td></tr>
<tr class="separator:a2811b15a2087f7fa1525098db2656f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e1b7228ab25024de5cbfb912eb0e0c"><td class="memItemLeft" align="right" valign="top"><a id="ab2e1b7228ab25024de5cbfb912eb0e0c" name="ab2e1b7228ab25024de5cbfb912eb0e0c"></a>
std::unordered_map&lt; <a class="el" href="constants_8h.html#aa145ea91c3e0724923e48e2eb0befe88">IdType</a>, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mDstStorageElementIdToNetworkLinkIdx</b></td></tr>
<tr class="memdesc:ab2e1b7228ab25024de5cbfb912eb0e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps the destination storage element id to a network link. Allows for faster look ups of <a class="el" href="class_c_storage_element.html#a6b98641f2ed3ba492ca4886028cfe621" title="Helper method to get a networklink connection this storage element with a given destination storage e...">GetNetworkLink()</a> <br /></td></tr>
<tr class="separator:ab2e1b7228ab25024de5cbfb912eb0e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Represents a storage element. Only basic functionality is implemented directly. The rest is delegated to the contained <a class="el" href="class_i_storage_element_delegate.html" title="Delegate definition declaring the methods required to implement a storage element delegate....">IStorageElementDelegate</a> object. </p>
<p >A storage element is the logical description of a certain storage area at an associated site. For example, a data centre could consist of tape storage and disk storage. Both represented by a different storage element. The key functionality of storage elements is the management of replicas, including their creation, deletion, and tracking their storage increase. Furthermore, storage elements allow being notified about operations, such as, new replica creation, data requests, or deletions. They also provide functionality to control and monitor the limitation of storage space. Finally, they are used to create network links. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8703731500cf7499f1733923c18daf4b" name="a8703731500cf7499f1733923c18daf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8703731500cf7499f1733923c18daf4b">&#9670;&nbsp;</a></span>CStorageElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CStorageElement::CStorageElement </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_site.html">ISite</a> *&#160;</td>
          <td class="paramname"><em>site</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDuplicateReplicas</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="constants_8h.html#a2dcadd59ab48e48ddc4b2a44e9a0cb75">SpaceType</a>&#160;</td>
          <td class="paramname"><em>limit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor to create a new storage element. Used by an <a class="el" href="class_i_site.html" title="Interface for a storage resource site.">ISite</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the new storage element (string will be consumed) </td></tr>
    <tr><td class="paramname">site</td><td>the site that this storage element belongs to and is owned by </td></tr>
    <tr><td class="paramname">allowDuplicateReplicas</td><td>whether to allow the storage element to contain multiple replicas of the same file </td></tr>
    <tr><td class="paramname">limit</td><td>the storage limit for this storage element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab0530d39192ebfa6c0332224e404f990" name="ab0530d39192ebfa6c0332224e404f990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0530d39192ebfa6c0332224e404f990">&#9670;&nbsp;</a></span>CanStoreVolume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CStorageElement::CanStoreVolume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="constants_8h.html#a2dcadd59ab48e48ddc4b2a44e9a0cb75">SpaceType</a>&#160;</td>
          <td class="paramname"><em>volume</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if the given volume can be allocated at this storage element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>desired volume to store</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the passed volume can be allocated, false otherwise </dd></dl>

</div>
</div>
<a id="a705d18996997988bb52033f7981cc6e1" name="a705d18996997988bb52033f7981cc6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705d18996997988bb52033f7981cc6e1">&#9670;&nbsp;</a></span>CreateNetworkLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto CStorageElement::CreateNetworkLink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_storage_element.html">CStorageElement</a> *&#160;</td>
          <td class="paramname"><em>dstStorageElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="constants_8h.html#a2dcadd59ab48e48ddc4b2a44e9a0cb75">SpaceType</a>&#160;</td>
          <td class="paramname"><em>bandwidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="class_c_network_link.html">CNetworkLink</a>*</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to create a new network link that originates from this storage element to the given destination storage element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstStorageElement</td><td>valid pointer to the destination storage element </td></tr>
    <tr><td class="paramname">bandwidth</td><td>bandwidth in bytes per second of the new network link</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new network link. The pointer is valid as long as the source storage element is valid. </dd></dl>

</div>
</div>
<a id="ac578cb7de73593f0fe50bf503dcdde92" name="ac578cb7de73593f0fe50bf503dcdde92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac578cb7de73593f0fe50bf503dcdde92">&#9670;&nbsp;</a></span>CreateReplica()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto CStorageElement::CreateReplica </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_file.html">SFile</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="constants_8h.html#ad0daaa7f1a5dd0956501ba62b4527644">TickType</a>&#160;</td>
          <td class="paramname"><em>now</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="struct_s_replica.html">SReplica</a>*</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to create a new replica of the given file at this storage element. Replica will be empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>pointer to the file of the new replica </td></tr>
    <tr><td class="paramname">now</td><td>simulation time the replica was created at</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the newly created replica. Can return nullptr depending on the delegate implementation, e.g., to prevent duplicates. Pointer is valid as long as the replica lives. The storage element will call corresponding action interfaces on replica deletion. </dd></dl>

</div>
</div>
<a id="a5c408be2771d70c4de8c4c69cb70a10c" name="a5c408be2771d70c4de8c4c69cb70a10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c408be2771d70c4de8c4c69cb70a10c">&#9670;&nbsp;</a></span>GetAllocatedStorage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto CStorageElement::GetAllocatedStorage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="constants_8h.html#a2dcadd59ab48e48ddc4b2a44e9a0cb75">SpaceType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the amount of storage space allocated at this storage element. </p>
<dl class="section return"><dt>Returns</dt><dd>the storage space allocated at this storage element</dd></dl>
<p>When a new replica is created, it will allocate storage the size of its file. As the replica is increased by a transfer, it increases the used storage and decreases the allocated storage by the same amount. This makes sure that a replica that is successfully created can be fully transferred to the storage element. </p>

</div>
</div>
<a id="a77cd228e5d276b0c2921b7a925087dec" name="a77cd228e5d276b0c2921b7a925087dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77cd228e5d276b0c2921b7a925087dec">&#9670;&nbsp;</a></span>GetLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto CStorageElement::GetLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="constants_8h.html#a2dcadd59ab48e48ddc4b2a44e9a0cb75">SpaceType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the maximum of storage that can used. </p>
<dl class="section return"><dt>Returns</dt><dd>the storage space limit for this storage element. 0 means the storage is unlimited. </dd></dl>

</div>
</div>
<a id="a6b98641f2ed3ba492ca4886028cfe621" name="a6b98641f2ed3ba492ca4886028cfe621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b98641f2ed3ba492ca4886028cfe621">&#9670;&nbsp;</a></span>GetNetworkLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto CStorageElement::GetNetworkLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_storage_element.html">CStorageElement</a> *&#160;</td>
          <td class="paramname"><em>dstStorageElement</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="class_c_network_link.html">CNetworkLink</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to get a networklink connection this storage element with a given destination storage element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstStorageElement</td><td>the destination storage element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the desired <a class="el" href="class_c_network_link.html" title="Class that represents a point to point network connection between two storage elements.">CNetworkLink</a> object if found or nullptr otherwise </dd></dl>

</div>
</div>
<a id="a7e36935ec99a2fb7b43a1a24aba87d93" name="a7e36935ec99a2fb7b43a1a24aba87d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e36935ec99a2fb7b43a1a24aba87d93">&#9670;&nbsp;</a></span>GetNetworkLinks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto CStorageElement::GetNetworkLinks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; const std::vector&lt;std::unique_ptr&lt;<a class="el" href="class_c_network_link.html">CNetworkLink</a>&gt;&gt;&amp;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter to get a const reference to the internal array storing the networklinks going out of this storage element. </p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the std::vector storing the outgoing network links </dd></dl>

</div>
</div>
<a id="aa6c0825313aa81074de26762c1657b1a" name="aa6c0825313aa81074de26762c1657b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c0825313aa81074de26762c1657b1a">&#9670;&nbsp;</a></span>GetReplicas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto CStorageElement::GetReplicas </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; const std::vector&lt;std::unique_ptr&lt;<a class="el" href="struct_s_replica.html">SReplica</a>&gt;&gt;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter to get a const reference to the internal array storing all replicas of the storage element (copying could be expensive) </p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the std::vector storing the replicas </dd></dl>

</div>
</div>
<a id="aed323816f6b9f7fb084b2f233e65e903" name="aed323816f6b9f7fb084b2f233e65e903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed323816f6b9f7fb084b2f233e65e903">&#9670;&nbsp;</a></span>GetUsedStorage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto CStorageElement::GetUsedStorage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="constants_8h.html#a2dcadd59ab48e48ddc4b2a44e9a0cb75">SpaceType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the amount of storage space used by this storage element. </p>
<dl class="section return"><dt>Returns</dt><dd>the storage space used by this storage element</dd></dl>
<p>When a new replica is created, it will allocate storage the size of its file. As the replica is increased by a transfer, it increases the used storage and decreases the allocated storage by the same amount. This makes sure that a replica that is successfully created can be fully transferred to the storage element. </p>

</div>
</div>
<a id="a6b8f3a873926efb2e04b9f40aac1d2ee" name="a6b8f3a873926efb2e04b9f40aac1d2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8f3a873926efb2e04b9f40aac1d2ee">&#9670;&nbsp;</a></span>GetUsedStorageLimitRatio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto CStorageElement::GetUsedStorageLimitRatio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the ratio between used storage and the storage limit. </p>
<dl class="section return"><dt>Returns</dt><dd>the ratio between used storage and the storage limit. 0 means the storage is unlimited. 1 means the storage is fully used. </dd></dl>

</div>
</div>
<a id="abc1de579e009b4462e8a9f34b43eede9" name="abc1de579e009b4462e8a9f34b43eede9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1de579e009b4462e8a9f34b43eede9">&#9670;&nbsp;</a></span>OnIncreaseReplica()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CStorageElement::OnIncreaseReplica </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_replica.html">SReplica</a> *&#160;</td>
          <td class="paramname"><em>replica</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="constants_8h.html#a2dcadd59ab48e48ddc4b2a44e9a0cb75">SpaceType</a>&#160;</td>
          <td class="paramname"><em>amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="constants_8h.html#ad0daaa7f1a5dd0956501ba62b4527644">TickType</a>&#160;</td>
          <td class="paramname"><em>now</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies the storage element that the storage spaced consumed by the given replica was increased. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">replica</td><td>valid pointer to the replica that was increased </td></tr>
    <tr><td class="paramname">amount</td><td>the amount that the replica was increased by </td></tr>
    <tr><td class="paramname">now</td><td>the time at which the replica was increased </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classgcp_1_1_c_bucket.html#a2db5cfd3d6b8ed6660e699ffe12ac094">gcp::CBucket</a>.</p>

</div>
</div>
<a id="ab95854dd7e31e47ae2643b8e47ea3456" name="ab95854dd7e31e47ae2643b8e47ea3456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95854dd7e31e47ae2643b8e47ea3456">&#9670;&nbsp;</a></span>OnOperation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CStorageElement::OnOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_storage_element.html#adea7b7bdc5316eec962f4cef2fbc9846">OPERATION</a>&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method that notifies the storage element about an executed operation, e.g., data access or deletion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>operation that is being executed </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classgcp_1_1_c_bucket.html#a0a14465fde375c7874ea4a819feee26e">gcp::CBucket</a>.</p>

</div>
</div>
<a id="a210cc8d65e56fc659e2886c724742903" name="a210cc8d65e56fc659e2886c724742903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210cc8d65e56fc659e2886c724742903">&#9670;&nbsp;</a></span>RemoveReplica()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CStorageElement::RemoveReplica </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_replica.html">SReplica</a> *&#160;</td>
          <td class="paramname"><em>replica</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="constants_8h.html#ad0daaa7f1a5dd0956501ba62b4527644">TickType</a>&#160;</td>
          <td class="paramname"><em>now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>needLock</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a replica from the storage element, freeing the storage space it consumed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">replica</td><td>valid pointer to the replica that should be removed. Asserts if the given replica belongs to a different storage element </td></tr>
    <tr><td class="paramname">now</td><td>the simulation time the replica was removed on </td></tr>
    <tr><td class="paramname">needLock</td><td>uses a mutex to lock protect the internal data structures if deletion is done in different threads </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classgcp_1_1_c_bucket.html#ae39b8bacb23585a9604a85ad8cadb058">gcp::CBucket</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>gacspp/infrastructure/<a class="el" href="_c_storage_element_8hpp_source.html">CStorageElement.hpp</a></li>
<li>gacspp/infrastructure/CStorageElement.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_c_storage_element.html">CStorageElement</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
